Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-12-17T17:19:29+08:00

====== 4-内在锁和同步 ======
创建日期 星期一 17 十二月 2018

同步是围绕称为内部锁或监视器锁的内部实体构建的。（API规范通常将此实体简称为“监视器”。）内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系。

每个对象都有一个与之关联的内在锁。按照惯例，需要对对象字段进行独占和一致访问的线程必须在访问对象之前获取对象的内部锁，然后在完成它们时释放内部锁。一个线程被称为在获得锁定和释放锁定之间拥有内在锁定。只要一个线程拥有一个内部锁，没有其他线程可以获得相同的锁。另一个线程在尝试获取锁时将阻塞。

当线程释放内部锁时，在该操作与同一锁的任何后续获取之间建立先发生关系。

===== 锁定同步方法 =====
当线程调用synchronized方法时，它会自动获取该方法对象的内部锁，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会发生锁定释放。

您可能想知道调用静态同步方法时会发生什么，因为静态方法与类相关联，而不是与对象相关联。在这种情况下，线程获取Class与类关联的对象的内部锁。因此，对类的静态字段的访问由一个锁控制，该锁与该类的任何实例的锁不同。

===== 同步语句 =====
创建同步代码的另一种方法是使用synchronized语句。与synchronized方法不同，synchronized语句必须指定提供内部锁的对象：

public void addName（String name）{
	__synchronized__（**this**）{
		lastName = name;
		nameCount ++;
	}
	nameList.add（名称）;
}

同步语句对于通过细粒度同步提高并发性也很有用, 可以做到精确的控制同步的语句范围，减少不必要的阻塞，性能更好．

===== 可重入同步? =====
回想一下，线程无法获取另一个线程拥有的锁。但是，一个线程可以获取它已经拥有的锁。允许线程多次获取相同的锁可启用重入同步。这描述了一种情况，其中同步代码直接或间接地调用也包含同步代码的方法，并且两组代码使用相同的锁。在没有可重入同步的情况下，同步代码必须采取许多额外的预防措施，以避免线程导致自身阻塞。
