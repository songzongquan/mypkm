Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-12-17T17:29:36+08:00

====== 5-原子访问 ======
创建日期 星期一 17 十二月 2018


在编程中，原子动作是一次有效发生的动作。原子动作不能在中间停止：它要么完全发生，要么根本不发生。在动作完成之前，原子动作的副作用是不可见的。

我们已经看到增量表达式，例如c++，没有描述原子动作。即使非常简单的表达式也可以定义可以分解为其他操作的复杂操作。但是，您可以指定原子操作：

1. 读取和写入对于引用变量和大多数原始变量（除了long和double之外的所有类型）都是原子的。
2. 读取和写入对于声明volatile的所有变量（包括 long和double变量）都是原子的。

原子动作不能交错，因此可以使用它们而不用担心线程干扰。但是，这并不能消除同步原子操作的所有需要​​，因为仍然可能存在内存一致性错误。使用volatile变量可以降低内存一致性错误的风险，因为对volatile变量的任何写入都会建立与之后读取同一变量的先发生关系。这意味着对volatile变量的更改始终对其他线程可见。更重要的是，它还意味着当一个线程读取一个volatile变量时，它不仅会看到最新的变化volatile，而且还会看到导致变化的代码的副作用。

使用简单的原子变量访问比通过同步代码访问这些变量更有效，但程序员需要更加小心以避免内存一致性错误。额外的努力是否值得取决于应用程序的大小和复杂性。

原子性的变量，用来实现同步一样的效果，性能较好，但不如用同步可靠，用volatile还可以，但是要小心使用，特殊情况，带是会有问题．

包中的一些类 java.util.concurrent提供了不依赖于同步的原子方法。我们将在高级并发对象一节中讨论它们。
