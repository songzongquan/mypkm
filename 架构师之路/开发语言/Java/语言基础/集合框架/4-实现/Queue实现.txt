Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-01-08T16:12:05+08:00

====== Queue实现 ======
创建日期 星期二 08 一月 2019

有通用实现与并发实现．

===== 通用实现 =====
前面的章节已经提到，LinkedList实现了Queue接口，实现了先进先出的的队列操作add,poll等．
PriorityQueue类是一个基于堆数据结构的，带优先级的队列，它根据在队列构建时指定的元素顺序来排序元素．这个顺序可以是元素的自然顺序或者是以某一个Comparator来指定的排序方式．
队列获取操作－有poll, remove, peek, 和 element －从队列的头部访问元素．头部的元素是当前排序方式的最小的元素．　__如果有多个元素被捆绑，头部也是这些元素之一，捆绑被任意的打破．__

PriorityQueue及其迭代器实现集合和迭代器接口的所有可选方法。方法迭代器中提供的迭代器不能保证以任何特定顺序遍历PriorityQueue的元素。对于有序遍历，考虑使用array.sort（pq.toＡrray（））。

===== 并发实现 =====
concurrent包包含一组同步队列接口和类。blockingqueue使用一些操作来扩展队列，这些操作在检索元素时等待队列变为非空，在存储元素时等待队列中的空间变为可用。此接口由以下类实现：

LinkedBlockingQueue - 由链接节点支持的可选有界FIFO阻塞队列
　基于链接节点的可选绑定阻塞队列。此队列命令元素FIFO（先进先出）。队列的头部是队列中最长时间的元素。队列的尾部是队列中最短时间的元素。在队列的尾部插入新元素，队列检索操作获取队列头部的元素。链接队列通常具有比基于阵列的队列更高的吞吐量，但在大多数并发应用程序中具有较低的可预测性能。
可选的容量绑定构造函数参数用作防止过多队列扩展的方法。如果未指明，容量等于Integer.MAX_VALUE。每次插入时都会动态创建链接节点，除非这会使队列超出容量。

该类及其迭代器实现了和接口的所有 可选方法。 CollectionIterator

ArrayBlockingQueue - 由数组支持的有界FIFO阻塞队列
　由数组支持的有界阻塞队列。此队列命令元素FIFO（先进先出）。队列的 头部是队列中最长时间的元素。队列的尾部是队列中最短时间的元素。在队列的尾部插入新元素，队列检索操作获取队列头部的元素。
这是一个经典的“有界缓冲区”，其中固定大小的数组包含由生产者插入并由消费者提取的元素。创建后，无法更改容量。尝试将put元素转换为完整队列将导致操作阻塞; 尝试take从空队列中的元素将同样阻止。

此类支持用于排序等待生产者和消费者线程的可选公平策略。默认情况下，不保证此顺序。但是，使用公平性构造的队列true以FIFO顺序授予线程访问权限。公平性通常会降低吞吐量，但会降低可变性并避免饥饿。
PriorityBlockingQueue - 由堆支持的无限制阻塞优先级队列
	一个无限制的阻塞队列，它使用与类相同的排序规则，PriorityQueue并提供阻塞检索操作。虽然此队列在逻辑上是无限制的，但由于资源耗尽（导致OutOfMemoryError），尝试添加可能会失败。这个类不允许使用 null元素。依赖于自然排序的优先级队列也不允许插入不可比较的对象（这样做会导致 ClassCastException）。
该类及其迭代器实现了和接口的所有 可选方法。在方法提供的迭代是不保证遍历的PriorityBlockingQueue的元素中的任何特定顺序。如果您需要有序遍历，请考虑使用 。此外，方法 可用于按优先级顺序删除部分或全部元素，并将它们放在另一个集合中。 CollectionIteratoriterator()Arrays.sort(pq.toArray())drainTo

此类的操作不保证具有相同优先级的元素的排序。如果需要强制执行排序，则可以定义使用辅助键来断开主要优先级值中的关系的自定义类或比较器。例如，这是一个将先进先出的打破平局应用于可比元素的类。要使用它，您将插入一个 new FIFOEntry(anEntry)而不是普通的条目对象。


DelayQueue - 由堆支持的基于时间的调度队列
　　一个无界阻塞队列的 Delayed元件，其中一个元件可以仅当其延迟期满作出。队列的头部是 Delayed其延迟在过去最远的元素。如果没有延迟到期，则没有头poll 并将返回null。当元素的getDelay(TimeUnit.NANOSECONDS)方法返回小于或等于零的值时，会发生过期 。即使使用take或不能删除未过期的元素poll，它们也会被视为普通元素。例如，该size方法返回已过期和未过期元素的计数。此队列不允许null元素。
该类及其迭代器实现了和接口的所有 可选方法。在方法提供的迭代是不保证遍历DelayQueue的元素中的任何特定顺序。 CollectionIteratoriterator()


SynchronousQueue- 使用该BlockingQueue接口的简单集合点机制
　　甲阻塞队列，其中每个插入操作必须由另一个线程等待一个相应的删除操作，并且反之亦然。同步队列没有任何内部容量，甚至没有容量。您不能 peek在同步队列中，因为只有在您尝试删除元素时才会出现该元素; 你不能插入一个元素（使用任何方法），除非另一个线程试图删除它; 你不能迭代，因为没有什么可以迭代。队列的 头部是第一个排队插入线程试图添加到队列的元素; 如果没有这样的排队线程，则没有可用于删除的元素 poll()并将返回null。出于其他Collection方法的目的 （例如contains），a SynchronousQueue充当空集合。此队列不允许null元素。
同步队列类似于CSP和Ada中使用的集合点通道。它们非常适用于切换设计，其中在一个线程中运行的对象必须与在另一个线程中运行的对象同步，以便将其传递给某些信息，事件或任务。

此类支持用于排序等待生产者和消费者线程的可选公平策略。默认情况下，不保证此顺序。但是，使用公平性构造的队列true以FIFO顺序授予线程访问权限。



在JDK 7中， TransferQueue专门BlockingQueue用于向队列添加元素的代码可以选择等待（阻塞）另一个线程中的代码来检索元素。TransferQueue有一个实现：

LinkedTransferQueue- TransferQueue基于链接节点的无界
