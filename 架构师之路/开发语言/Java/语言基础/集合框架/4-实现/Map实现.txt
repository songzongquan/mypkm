Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-01-08T14:17:22+08:00

====== Map实现 ======
创建日期 星期二 08 一月 2019

有通用实现，特殊实现与并发实现．

===== 通用实现 =====

有三个通用实现：ＨａｓｈＭａｐ，ＴｒｅｅＭａｐ，LinkedＨａｓｈMap，如果你需要用SortedMap操作或者需要按有序的key进行集合视图的操作，那么要用ＴｒｅｅＭａｐ．如果你需要最大化的速度或不关心迭代的的顺序，那么用ＨａｓｈＭａｐ．当你需要接近ＨａｓｈＭａｐ的速度又要按顺序迭代，那么就用LinkedMap. 也就是说，这个解决方案与Ｓｅｔ的方案非常类似，在Ｓｅｔ　实现这一节中的说明也都适合于Ｍａｐ的实现．

ＬｉｎｋｅｄＨａｓｈＭａｐ提供了两个能力，LinkedHashSet是没有的．当你创建一个LinkedHashMap时，你可以按ｋｅｙ来排序它的元素，而不是在插入时实现，也就是说，只需查找与键关联的值，该键会到达映射的末尾．此外，Linkedhashmap提供了removeedoldestry方法，可以重写该方法，以强制实施策略，以便在将新映射添加到映射时自动删除过时映射。这使得实现自定义缓存非常容易。
例如，此覆盖将允许映射增长到多达100个条目，然后它将在每次添加新条目时删除最老的条目，保持总有100个条目的稳定状态。
private static final int MAX_ENTRIES = 100;

protected boolean removeEldestEntry(Map.Entry eldest) {
	return size() > MAX_ENTRIES;
}

===== 特殊实现 =====

有三个特殊实现： EnumMap, WeakHashMap 和 IdentityHashMaweakhashmap是map接口的一个实现，它只存储对其键的弱引用。仅存储弱引用允许在不再在weakhashmap之外引用键值对时对其进行垃圾收集。此类提供了利用弱引用的强大功能的最简单方法。它对于实现“类似注册表”的数据结构很有用，当任何线程都无法访问某个条目的键时，该条目的实用程序将消失。p.　EnumMap，内部用一个array来实现，是一个用enum来作为ｋｅｙ的高性能的ｍａｐ实现．这个实现混合了ｍａｐ的丰富而安全的接口和接近array的性能．如果你要映射enum到一个值，首选用EnumMap.

weakhashmap是map接口的一个实现，它只存储对其键的弱引用。仅存储弱引用允许在不再在weakhashmap之外引用键值对时对其进行垃圾收集。此类提供了利用弱引用的强大功能的最简单方法。它对于实现“类似注册表”的数据结构很有用，当任何线程都无法访问某个条目的键时，该条目的实用程序将消失。

IdentityHashMap是基于哈希表的基于身份的映射实现。此类对于拓扑保护对象图转换（如序列化或深度复制）很有用。要执行这样的转换，您需要维护一个基于标识的“节点表”，它可以跟踪哪些对象已经被看到。基于身份的映射还用于维护动态调试器和类似系统中的对象到元信息映射。最后，基于身份的映射对于阻止有意歪曲equals方法的“欺骗攻击”非常有用，因为identityhashmap从不在其键上调用equals方法。这个实现的另一个好处是它很快。

===== 并发实现 =====

concurrent包包含concurrent map接口，该接口使用原子putifassent、remove和replace方法扩展map，以及该接口的concurrenthashmap实现。

ConcurrentHashMap是一种高度并发、高性能的实现，由哈希表支持。此实现在执行检索时从不阻塞，并允许客户端选择更新的并发级别。它的目的是作为哈希表的替代品：除了实现Concurrentmap之外，它还支持哈希表特有的所有遗留方法。同样，如果您不需要遗留操作，请注意使用Concurrentmap接口对其进行操作。
