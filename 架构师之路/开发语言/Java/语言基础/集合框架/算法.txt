Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-01-10T13:25:33+08:00

====== 算法 ======
创建日期 星期四 10 一月 2019

述了JDK提供的用于对集合进行操作的多态算法。运气好的话，你再也不用写自己的排序程序了！

这里描述的多态算法是Java平台提供的可重用功能。所有这些都来自 Collections类，并且都采用静态方法的形式，其第一个参数是要在其上执行操作的集合。Java平台提供的绝大多数算法都在List实例上运行，但其中一些算法 在任意 Collection实例上运行。本节简要介绍以下算法：

===== 排序 =====
该sort算法重新排序a List，使得其元素根据排序关系按升序排列。提供了两种形式的操作。简单形式List根据其元素的自然顺序对其进行排序和排序。如果您不熟悉自然排序的概念，请阅读 对象排序部分。

该sort操作使用一种快速稳定的略微优化的合并排序算法：
Coollections.sort(list)

快速：保证及时运行n log(n)并在几乎排序的列表上运行得更快。经验测试显示它与高度优化的快速排序一样快。快速排序通常被认为比合并排序更快但不稳定并且不保证n log(n)性能。
稳定：它不会重新排序相同的元素。如果您对不同的属性重复排序相同的列表，这一点很重要。如果邮件程序的用户通过邮寄日期对收件箱进行排序，然后由发件人对其进行排序，则用户自然希望来自给定发件人的现在连续的邮件列表（仍）按邮件日期排序。仅当第二种排序稳定时才能保证这一点。

另一种方法是可以指定Comparator的排序：
Collections.sort(list,Comparator compar)

===== 洗牌 =====
洗牌算法做的是和排序相反的事情．破坏了可能存在于List中的任何顺序。也就是说，L算法基于来自随机源的输入重新排序，使得假设公平的随机源，所有可能的排列以相等的可能性发生。该算法在实现机会游戏时很有用。例如，它可以用于混洗代表甲板List的Card对象。此外，它对生成测试用例很有用。

此操作有两种形式：一种采用List并使用默认的随机源，另一种需要调用者提供 Random对象以用作随机源。Collections.shuffle(list,new Random()),

===== 常规数据操作 =====
本Collections类提供了在List对象上做日常的数据处理5个对比算法，所有这些都是非常简单：

reverse- 颠倒List中元素的顺序。
fill- 用指定的值覆盖List中的每个元素。此操作对于重新初始化List非常有用。
copy- 接受两个参数，一个目标List和一个源List，并将源的元素复制到目标中，覆盖其内容。目的地List必须至少与来源一样长。如果它更长，则目标List中的其余元素不受影响。
swap- 将元素交换到List中的指定位置。
addAll- 将所有指定的元素添加到a Collection。要添加的元素可以单独指定，也可以指定为数组。

===== 搜索 =====

binarySearch  算法在一个排序的List中搜索一个特定的元素．这个算法有两种形式，第一种形式要求输入一个ｌｉｓｔ和一个要元素的关键字．这种形式假定这个ｌｉｓｔ的元素是按自然顺序升序排过过序的．
另一种形式则除list与要搜索的关键外，还需要一个Comparator对象，它假定这个ｌｉｓｔ是按Comparator进行过升序排序的．在进行搜索前它会先执行一个排序算法．

两种算法的返回值是一样的，如果查到了则返回其索引，如果查不到则返回（－(插入点）－１），插入点是指指的值将被插入的位置，或者比值大的第一个元素的索引，或者如果所有元素都小于这个值，则返回的是list.size()的值．

这一公认的丑陋公式保证，只有在找到搜索键的情况下，返回值才会大于等于0。把布尔值（found）和整数（index）组合成单个int返回值基本上是一种黑客行为。
以下成语（可用于两种形式的binarySearch操作）查找指定的搜索键，并将其插入适当的位置（如果它尚不存在）。

int pos = Collections.binarySearch（list，key）; 
if（pos <0）
   __l.add（-pos-1，key）;__

===== 组成 =====

频率（frequency)　和　不相交(disjoint)　算法用于测试　一个或多个集合　关于组合的某些方面．
frequency - 计算指定元素在指定集合中出现的次数
disjoint- 确定两个Collections是否脱节; 也就是说，它们是否不包含任何共同的元素

===== 寻找极值 =====
min 和　ｍａｘ算法分别返回一个集合中的最小值和最大值．这两种操作都有两种形式。简单形式获取一个集合作为参数，并按自然排序法，返回其最大或最小值，另一种形式可以另外接收一个Comparator，它会返回按Comparator进行排序后的最大或最小值．

