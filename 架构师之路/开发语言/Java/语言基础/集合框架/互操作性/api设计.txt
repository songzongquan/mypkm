Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-01-11T14:52:17+08:00

====== api设计 ======
创建日期 星期五 11 一月 2019

在这个简短但重要的部分中，您将学习一些简单的指导原则，使您的API能够与遵循这些指南的所有其他API无缝地互操作。从本质上讲，这些规则定义了在集合世界中成为一个好的“公民”需要什么。

===== 参数 =====
如果您的API包含需要输入集合的方法，那么将相关参数类型声明为集合接口类型之一是至关重要的 。永远不要使用 实现类型，因为这会破坏基于接口的集合框架的目的，即允许操作集合而不考虑实现细节。

此外，您应该始终使用最不具体的类型。例如，不需要a List或a Setif a Collectionwould。这并不是说你永远不需要输入List或Set输入; 如果方法依赖于其中一个接口的属性，则这样做是正确的。例如，Java平台提供的许多算法都需要List输入，因为它们依赖于列表的排序事实。但是，作为一般规则，输入时使用的最佳类型是最常用的：Collection和Map。

===== 返回值 =====
使用返回值比使用输入参数更灵活。返回实现或扩展其中一个集合接口的任何类型的对象都可以。这可以是接口之一，也可以是扩展或实现这些接口之一的特殊用途类型。

例如，可以想象一个名为的图像处理包ImageList返回实现的新类的对象List。除了List操作之外，还ImageList可以支持任何特定于应用程序的操作。例如，它可能会提供一个indexImage操作，该操作返回包含每个图形的缩略图图像的图像ImageList。值得注意的是，即使API ImageList在输出上提供实例，它也应该接受输入上的任意Collection（或可能List）实例。
__永远不要定义自己的ad hoc collection类，并在输入时需要此类的对象。通过这样做，您将失去Java Collections Framework提供的所有 好处。__
__从某种意义上说，返回值应该具有输入参数的相反行为：最好返回最具体的适用集合接口，而不是最常见的。__例如，如果您确定您将始终返回a SortedMap，则应该为相关方法提供返回类型SortedMap而不是Map。SortedMap实例比普通Map实例更耗时，而且功能更强大。鉴于您的模块已经投入时间来构建一个SortedMap，因此让用户访问其增强的功能是很有意义的。此外，用户将能够将返回的对象传递给需要a的方法SortedMap以及接受任何方法的方法Map。

===== 旧版API =====
目前有很多API可以定义自己的临时集合类型。虽然这很不幸，但鉴于Java平台的前两个主要版本中没有Collections Framework，这是生活中的事实。假设您拥有其中一个API; 这是你能做些什么。

如果可能，请改进旧版集合类型以实现其中一个标准集合接口。然后，您返回的所有集合将与其他基于集合的API平滑地互操作。如果这是不可能的（例如，因为一个或多个预先存在的类型签名与标准集合接口冲突），请定义一个适配器类，它包装您的一个旧集合对象，使其可用作标准集合。（Adapter该类是自定义实现的示例 。）

如果可能，使用遵循输入准则的新调用来改进API，以接受标准集合接口的对象。此类调用可以与采用旧版集合类型的调用共存。如果这是不可能的，请为遗留类型提供构造函数或静态工厂，以获取其中一个标准接口的对象，并返回包含相同元素（或映射）的旧集合。这些方法中的任何一种都允许用户将任意集合传递到您的API中。
