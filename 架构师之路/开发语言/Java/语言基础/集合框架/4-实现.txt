Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-01-06T20:44:10+08:00

====== 4-实现 ======
创建日期 星期日 06 一月 2019

实现是用于存储集合的数据对象，它实现了“接口”部分中描述 的接口。本课程描述了以下几种实现：


* **通用实现**是最常用的实现，专为日常使用而设计。它们在标题为通用实现的表中进行了总结。
* 专**用实现**旨在用于特殊情况，并显示非标准性能特征，使用限制或行为。
* **并发实现**旨在支持高并发性，通常以牺牲单线程性能为代价。这些实现是java.util.concurrent包的一部分。
* **包装器**实现与其他类型的实现（通常是通用实现）结合使用，以提供增加或限制的功能。
* **便利实现**是通常通过静态工厂方法提供的小型实现，为特殊集合（例如，单例集）的通用实现提供方便，有效的替代方案。
* **抽象实现**是骨架实现，有助于构建自定义实现 - 稍后将在“ 自定义集合实现”部分中进行介绍。一个高级主题，并不是特别困难，但相对较少的人需要这样做。
通用实现总结 在下表中。


{{./pasted_image.png}}
你可以从表中看到，Java集合框架提供了几种通用的实现 Set， List以及 Map接口。在每种情况下，一个实现 - HashSet， ArrayList和 HashMap- 显然是大多数应用程序使用的，所有其他条件相同。请注意，表 SortedSet和 SortedMap接口在表中没有行。每个接口都有一个实现 （TreeSet和 TreeMap），并列在行Set和Map行中。有两个通用Queue实现 - LinkedList也是一个List实现，并且 PriorityQueue从表中省略。这两个实现提供了非常不同的语义：LinkedList提供FIFO语义，同时PriorityQueue根据其值对其元素进行排序。

每个通用实现都提供其接口中包含的所有可选操作。所有允许null元素，键和值。无同步（线程安全）。它们都具有快速失败的迭代器，它可以在迭代期间检测非法并发修改，并且可以快速，干净地失败，而不是在未来的未确定时间冒任意，不确定的行为。所有人都Serializable支持公共clone方法。

这些实现是不同步的这一事实代表了对过去的打破：遗留集合Vector并且Hashtable是同步的。采用本方法是因为当同步没有任何好处时经常使用集合。这些用途包括单线程使用，只读使用，以及用作进行自身同步的大型数据对象的一部分。一般来说，良好的API设计实践不会让用户为他们不使用的功能付费。此外，在某些情况下，不必要的同步可能导致死锁。

如果需要线程安全集合，则“ 包装器实现”部分中描述的同步包装器 允许将任何集合转换为同步集合。因此，同步对于通用实现是可选的，而对于遗留实现是必需的。此外，该java.util.concurrent包提供的并发实现BlockingQueue接口，其延伸Queue，并且所述的ConcurrentMap接口，其延伸Map。这些实现提供了比仅仅同步实现更高的并发性。

通常，您应该考虑接口，而不是实现。这就是本节中没有编程示例的原因。在大多数情况下，实施的选择仅影响性能。接口部分中提到的首选样式 Collection是在创建a时选择实现，并立即将新集合分配给相应接口类型的变量（或将集合传递给期望接口参数的方法类型）。通过这种方式，程序不会依赖于给定实现中的任何添加方法，使程序员可以随时通过性能问题或行为细节保证更改实现。

以下部分简要讨论了实现。使用诸如常数时间，对数，线性，n log（n）和二次方的单词来描述实现的性能，以指代执行操作的时间复杂度的渐近上限。所有这些都是相当满口的，如果你不知道它意味着什么并不重要。如果您有兴趣了解更多信息，请参阅任何优秀的算法教科书。需要记住的一点是，这种性能指标有其局限性。有时，名义上较慢的实施可能会更快。如有疑问，请测量性能！
